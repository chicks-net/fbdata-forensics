#!/usr/bin/env perl

use strict;
use warnings;
use Data::Dumper; # just for debugging
use File::Slurp qw(read_file);
#use LWP::Simple qw(get);
use HTML::TreeBuilder;

my ($data_dir) = @ARGV;

# variables
my @keywords;

# main
read_keywords();

validate_dir($data_dir);

my ($who,$when) = get_download_timestamp();

parse_timeline();

parse_messages();

# functions
sub read_keywords {
	my $keyfile = "keywords.txt";
	my $key_content = read_file($keyfile);
	chomp($key_content);
	@keywords = split(/\s+/,$key_content);
	print Dumper(\@keywords);
}

sub validate_dir {
	my ($data_dir) = @_;

	unless (-d $data_dir) {
		die "not a directory: $data_dir";
	}

	chdir($data_dir) or die "couldn't chdir($data_dir): $!";

	# needed for Download date
	unless (-f 'index.htm') {
		die "no index.htm";
	}

	foreach my $dir (qw( html messages photos videos)) {
		unless (-d $dir) {
			die "no $dir directory";
		}
	}

	# the timeline
	unless (-f 'html/timeline.htm') {
		die "no html/timeline.htm";
	}

	print "$data_dir looks like a Facebook data dump\n";
}

sub get_download_timestamp {
	#system("pwd");
	my $index_htm = read_file("index.htm");
	my $index_size = length($index_htm);
	print "got $index_size bytes in index.htm\n";

	my $tree = HTML::TreeBuilder->new;    # empty tree
	$tree->parse_content($index_htm);

#	$tree->dump;
	my $downloaded_div = $tree->look_down('_tag' => 'div', class => 'footer');
	my $downloaded_raw = $downloaded_div->as_text;
	$downloaded_raw =~ /Downloaded by (.+) on (.+)$/;
	my $who = $1;
	my $when = $2;
	return($who,$when);
}

sub parse_timeline {
	my $timeline_htm = read_file("html/timeline.htm");
	my $timeline_size = length($timeline_htm);
	print "got $timeline_size bytes in timeline.htm\n";

	my $tree = HTML::TreeBuilder->new;    # empty tree
	$tree->parse_content($timeline_htm);
	print "parsed timeline\n"; # TODO: include time

	my $contents_div = $tree->look_down('_tag' => 'div', class => 'contents');

	my @posts = $contents_div->look_down('_tag' => 'p');
	my $post_count = scalar @posts;
	print "found $post_count posts\n";

	my %key_counts;
	foreach my $post (@posts) {
		my $comment_div = $post->look_down('_tag' => 'div', class => 'comment');
		my $meta = $post->look_down('_tag' => 'div', class => 'meta')->as_text;
		# TODO: pull out "X Y Z shared a post" part that isn't in a div

		my $comment;
		if (defined $comment_div) {
			$comment = $comment_div->as_text;
		} else {
			$comment = "undefined";
		}

		foreach my $keyword (@keywords) {
			if ($comment =~ /$keyword/i) {
				print "matched $keyword:\n";
				print "\tmeta=$meta\n";
				print "\tcomment=$comment\n";

				$key_counts{$keyword}++;
			}
		}
	}
	print Dumper(\%key_counts);

	die "unimplemented parse..............";
}

sub parse_messages {
	die "unimplemented parse msg";
}
